__NOTOC__
* [[:#String Funciones | String Funciones]]
* [[:#ASCII | ASCII]]
* [[:#BIN | BIN]]
* [[:#BINARY OPERATOR | BINARY OPERATOR]]
* [[:#BIT_LENGTH | BIT_LENGTH]]
* [[:#CAST | CAST]]
* [[:#CHAR | CHAR]]
* [[:#CHARACTER_LENGTH | CHARACTER_LENGTH]]
* [[:#CHAR_LENGTH | CHAR_LENGTH]]
* [[:#CONCAT | CONCAT]]
* [[:#CONCAT_WS | CONCAT_WS]]
* [[:#CONVERT | CONVERT]]
* [[:#Dynamic Columns Functions | Dynamic Columns Functions]]
* [[:#ELT | ELT]]
* [[:#EXPORT_SET | EXPORT_SET]]
* [[:#EXTRACTVALUE | EXTRACTVALUE]]
* [[:#FIELD | FIELD]]
* [[:#FIND_IN_SET | IN_SET]]
* [[:#FORMAT | FROMAT]]
* [[:#HEX | HEX]]
* [[:#INSERT Function | INSERT Function]]
* [[:#INSTR | INSTR]]
* [[:#LCASE | LCASE]]
* [[:#LEFT | LEFT]]
* [[:#LENGTH | LENGTH]]
* [[:#LIKE | LIKE]]
* [[:#LOAD_FILE | LOAD_FILE]]
* [[:#LOCATE | LOCATE]]
* [[:#LOWER | LOWER]]
* [[:#LPAD | LPAD]]
* [[:#LTRIM | LTRIM]]
* [[:#MAKE_SET | MAKE_SET]]
* [[:#MATCH AGAINST | MATCH_AGAINST]]
* [[:#Stopwords | Stopwords]]
* [[:#MID | MID]]
* [[:#NOT LIKE NOT LIKE| NOT LIKE]]
* [[:#OT REGEXP | OT REGEXP]]
* [[:#OCTET_LENGTH | OCTET_LENGTH]]
* [[:#ORD | ORD]]
* [[:#POSITION | POSITION]]
* [[:#QUOTE | QUOTE]]
* [[:#REPEAT Function | REPEAT Función]]
* [[:#REPLACE Function | REPLACE Función]]
* [[:#REVERSE | REVERSE]]
* [[:#RIGHT | RIGHT]]
* [[:# RPAD | RPAD]]
* [[:# RTRIM | RTRIM]]
* [[:#SOUNDEX | SOUNDEX]]
* [[:#SOUNDS LIKE | SOUNDS LIKE]]
* [[:#SPACE | SPACE]]
* [[:#STRCMP | STRCMP]]
* [[:#SUBSTR | SUBSTR]]
* [[:#SUBSTRING | SUBSTRING]]
* [[:#SUBSTRING_INDEX | SUBSTRING_INDEX]]
* [[:#TRIM | TRIM]]
* [[:#UCASE | UCASE]]
* [[:#UNHEX | UNHEX]]
* [[:#UPDATEXML | UPDATEXML]]
* [[:#UPPER | UPPER]]
* [[:#FROM_BASE64 | BASE64]]
* [[:#TO_BASE64 | TO_BBAS64]]
* [[:#WEIGHT_STRING | WEIGHT_STRING]]

= String Funciones =
== ASCII ==
 <b>Sintaxis</b>
 
 ASCII(str)
 
 <b>Description</b>
 Devuelve el valor ASCII carácter más a la izquierda en la cadena str.
 Devuelve 0 si str está vacía y NULL si str es NULL.
 
 ASCII () funciona de caracteres de 8 bits.
 
 <b>Ejemplos</b>
 
 [rrc@Pwyr ~]$ mysql -u rrc -p
 Enter password: 
 Welcome to the MariaDB monitor.  Commands end with ; or \g.
 Your MariaDB connection id is 7
 Server version: 10.0.25-MariaDB Mageia MariaDB Server
 
 Copyright (c) 2000, 2016, Oracle, MariaDB Corporation Ab and others.
 
 Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
 
 MariaDB [(none)]> SELECT ASCII(9);
 +----------+
 | ASCII(9) |
 +----------+
 |       57 |
 +----------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT ASCII('9');
 +------------+
 | ASCII('9') |
 +------------+
 |         57 |
 +------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT ASCII('abc');
 +--------------+
 | ASCII('abc') |
 +--------------+
 |           97 |
 +--------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT ASCII("Char ¡");
 +------------------+
 | ASCII("Char ¡")  |
 +------------------+
 |               67 |
 +------------------+
 1 row in set (0.00 sec)
  
       ASCII is the American Standard Code for Information Interchange.  It is
       a 7-bit code.  Many 8-bit codes (e.g., ISO  8859-1)  contain  ASCII  as
       their  lower  half.  The international counterpart of ASCII is known as
       ISO 646-IRV.
 
       The following table contains the 128 ASCII characters.
 
       C program '\X' escapes are noted.
 
       Oct   Dec   Hex   Char                        Oct   Dec   Hex   Char
       ────────────────────────────────────────────────────────────────────────
       000   0     00    NUL '\0' (null character)   100   64    40    @
       001   1     01    SOH (start of heading)      101   65    41    A
       002   2     02    STX (start of text)         102   66    42    B
       003   3     03    ETX (end of text)           103   67    43    C
       004   4     04    EOT (end of transmission)   104   68    44    D
       005   5     05    ENQ (enquiry)               105   69    45    E
       006   6     06    ACK (acknowledge)           106   70    46    F
       007   7     07    BEL '\a' (bell)             107   71    47    G
       010   8     08    BS  '\b' (backspace)        110   72    48    H
       011   9     09    HT  '\t' (horizontal tab)   111   73    49    I
       012   10    0A    LF  '\n' (new line)         112   74    4A    J
       013   11    0B    VT  '\v' (vertical tab)     113   75    4B    K
       014   12    0C    FF  '\f' (form feed)        114   76    4C    L
       015   13    0D    CR  '\r' (carriage ret)     115   77    4D    M
       016   14    0E    SO  (shift out)             116   78    4E    N
       017   15    0F    SI  (shift in)              117   79    4F    O
       020   16    10    DLE (data link escape)      120   80    50    P
       021   17    11    DC1 (device control 1)      121   81    51    Q
       022   18    12    DC2 (device control 2)      122   82    52    R
       023   19    13    DC3 (device control 3)      123   83    53    S
       024   20    14    DC4 (device control 4)      124   84    54    T
       025   21    15    NAK (negative ack.)         125   85    55    U
       026   22    16    SYN (synchronous idle)      126   86    56    V
       027   23    17    ETB (end of trans. blk)     127   87    57    W
       030   24    18    CAN (cancel)                130   88    58    X
       031   25    19    EM  (end of medium)         131   89    59    Y
       032   26    1A    SUB (substitute)            132   90    5A    Z
       033   27    1B    ESC (escape)                133   91    5B    [
       034   28    1C    FS  (file separator)        134   92    5C    \  '\\'
       035   29    1D    GS  (group separator)       135   93    5D    ]
       036   30    1E    RS  (record separator)      136   94    5E    ^
       037   31    1F    US  (unit separator)        137   95    5F    _
       040   32    20    SPACE                       140   96    60    `
       041   33    21    !                           141   97    61    a
       042   34    22    "                           142   98    62    b
       043   35    23    #                           143   99    63    c
       044   36    24    $                           144   100   64    d
       045   37    25    %                           145   101   65    e
       046   38    26    &                           146   102   66    f
       047   39    27    '                           147   103   67    g
       050   40    28    (                           150   104   68    h
       051   41    29    )                           151   105   69    i
       052   42    2A    *                           152   106   6A    j
       053   43    2B    +                           153   107   6B    k
       054   44    2C    ,                           154   108   6C    l
       055   45    2D    -                           155   109   6D    m
       056   46    2E    .                           156   110   6E    n
       057   47    2F    /                           157   111   6F    o
       060   48    30    0                           160   112   70    p
       061   49    31    1                           161   113   71    q
       062   50    32    2                           162   114   72    r
       063   51    33    3                           163   115   73    s
       064   52    34    4                           164   116   74    t
       065   53    35    5                           165   117   75    u
       066   54    36    6                           166   118   76    v
       067   55    37    7                           167   119   77    w
       070   56    38    8                           170   120   78    x
       071   57    39    9                           171   121   79    y
       072   58    3A    :                           172   122   7A    z
       073   59    3B    ;                           173   123   7B    {
       074   60    3C    <                           174   124   7C    |
       075   61    3D    =                           175   125   7D    }
       076   62    3E    >                           176   126   7E    ~
       077   63    3F    ?                           177   127   7F    DEL

== BIN ==
 <b>Sintaxis</b>
 
 BIN( N )
 
 <b>Description</b>
 
 Devuelve una cadena que representa el valor binario de N, 
 donde N es un número longlong (BIGINT). Esto es equivalente
 a CONV( N, 10,2 ). 
 N debe ser positivo. Si N es un float, se truncará. 
 Retorna NULL si N es NULL.
 
 <b>Ejemplos</b>
 MariaDB [(none)]> SELECT BIN( 12 );
 +-----------+
 | BIN( 12 ) |
 +-----------+
 | 1100      |
 +-----------+
 1 row in set (0.02 sec)
 
 MariaDB [(none)]> SELECT BIN( 12.3 );
 +-------------+
 | BIN( 12.3 ) |
 +-------------+
 | 1100        |
 +-------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT BIN( -12.3 );
 +------------------------------------------------------------------+
 | BIN( -12.3 )                                                     |
 +------------------------------------------------------------------+
 | 1111111111111111111111111111111111111111111111111111111111110100 |
 +------------------------------------------------------------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT BIN(  );
 ERROR 1582 (42000): Incorrect parameter count in the call to native function 'BIN'
 
 MariaDB [(none)]> SELECT BIN( NULL );
 +-------------+
 | BIN( NULL ) |
 +-------------+
 | NULL        |
 +-------------+
 1 row in set (0.00 sec)

== BINARY ==
 <b>Sintaxis</b>
 
 BINARY
 
 <b>Descripción</b>
 
 El operador BINARY casts la cadena que sigue a una cadena binaria.
 Esta es una manera fácil de forzar una comparación columna para hacerse
 byte por byte en lugar de caracter por caracter. Esto hace que la
 comparación sea sensible a mayúsculas incluso si la columna no se define
 como binario o BLOB. BINARIO también provoca que los espacios finales
 sea significativa.
 
 <b>Ejemplos</b>
 
 MariaDB [(none)]> SELECT 'a' = 'A';
 +-----------+
 | 'a' = 'A' |
 +-----------+
 |         1 |
 +-----------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT BINARY 'a' = 'A';
 +------------------+
 | BINARY 'a' = 'A' |
 +------------------+
 |                0 |
 +------------------+
 1 row in set (0.01 sec)
 
 MariaDB [(none)]> SELECT 'a' = 'a ';
 +------------+
 | 'a' = 'a ' |
 +------------+
 |          1 |
 +------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT BINARY 'a' = 'a ';
 +-------------------+
 | BINARY 'a' = 'a ' |
 +-------------------+
 |                 0 |
 +-------------------+
 1 row in set (0.00 sec)

== BIT_LENGTH ==
 <b>Sintaxis</b>
 
 BIT_LENGTH( str )
 
 <b>Dexcripción</b>
 
 Devuelve la longitud de la cadena str en bits.
 Si str no es una cadena, se convierte en cadena.
 Si str es NULL, devuelve NULL.
 
 <b>Ejemplos</b>
 
 MariaDB [(none)]> SELECT BIT_LENGTH('texto');
 +---------------------+
 | BIT_LENGTH('texto') |
 +---------------------+
 |                  40 |
 +---------------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT BIT_LENGTH('Como');
 +--------------------+
 | BIT_LENGTH('Como') |
 +--------------------+
 |                 32 |
 +--------------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT BIT_LENGTH('Cómo');
 +---------------------+
 | BIT_LENGTH('Cómo')  |
 +---------------------+
 |                  40 |
 +---------------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT BIT_LENGTH('¿Cómo están ustedes');
 +--------------------------------------+
 | BIT_LENGTH('¿Cómo están ustedes')    |
 +--------------------------------------+
 |                                  176 |
 +--------------------------------------+
 1 row in set (0.00 sec)
 
== CAST ==
 <b>Sintaxis</b>
 
 CAST( expr AS type )
 
 <b>Descripción</b>
 
 La función CAST() toma un valor de un tipo y produce un valor de otro tipo,
 similar a CONVERT().
 
 La principal diferencia entre el CAST() y CONVERT() es que CONVERT( expr, tipo )
 es la sintaxis ODBC mientras CAST( expr como tipo ) y CONVERT(... USING ...)
 están SQL92 sintaxis.
 
 Hasta MariaDB 05/05/31, X'HHHH ', la sintaxis SQL estándar para cadenas literales
 binarios, erróneamente trabajado de la misma manera como 0xHHHH. En 5.5.31 se cambió
 intencionadamente a comportarse como una cadena en todos los contextos (y nunca como un número).
 
 Esto introduce una incompatibilidad con las versiones anteriores de MariaDB, y todas las
 versiones de MySQL (véase el ejemplo a continuación).
 
 <b>Ejemplo</b>
 
 MariaDB [(none)]> SELECT CAST("abc" as binary);
 +-----------------------+
 | CAST("abc" as binary) |
 +-----------------------+
 | abc                   |
 +-----------------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT CAST("1" as unsigned integer);
 +-------------------------------+
 | CAST("1" as unsigned integer) |
 +-------------------------------+
 |                             1 |
 +-------------------------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT CAST("-1" as unsigned integer);
 +--------------------------------+
 | CAST("-1" as unsigned integer) |
 +--------------------------------+
 |           18446744073709551615 |
 +--------------------------------+
 1 row in set, 1 warning (0.00 sec)
 
 El uso de CAST() para ordenar un campo ENUM como CHAR en lugar del valor numérico interno:
 
 MariaDB [Prueba1]> CREATE TABLE enum_list (enum_field enum('c','a','b'));
 Query OK, 0 rows affected (0.92 sec)
 
 MariaDB [Prueba1]> INSERT INTO enum_list (enum_field) VALUES('c'),('a'),('c'),('b');
 Query OK, 4 rows affected (0.11 sec)
 Records: 4  Duplicates: 0  Warnings: 0
 
 MariaDB [Prueba1]> SELECT * FROM enum_list ORDER BY enum_field;
 +------------+
 | enum_field |
 +------------+
 | c          |
 | c          |
 | a          |
 | b          |
 +------------+
 4 rows in set (0.03 sec)
 
 MariaDB [Prueba1]> SELECT * FROM enum_list ORDER BY CAST(enum_field AS CHAR);
 +------------+
 | enum_field |
 +------------+
 | a          |
 | b          |
 | c          |
 | c          |
 +------------+
 4 rows in set (0.00 sec)

== CHAR ==
 <b>Sintaxis</b>
 
 CHAR( N, ... [USING charset_name] )
 
 <b>Dexcripción</b>
  
 CHAR() interpreta cada argumento como enteros y devuelve una cadena
 formada por los caracteres dados por los códigos de tales enteros.
 Los valores NULL se omiten. De forma predeterminada, CHAR() devuelve
 una cadena binaria. Para producir una cadena en un conjunto de caracteres
 dada, utilice la cláusula USING opcional:
 
 SELECT CHARSET( CHAR( 0x65 ) ), CHARSET( CHAR( 0x65 USING utf8 ) );
 +-------------------------+------------------------------------+
 | CHARSET( CHAR( 0x65 ) ) | CHARSET( CHAR( 0x65 USING utf8 ) ) |
 +-------------------------+------------------------------------+
 | binary                  | utf8                               |
 +-------------------------+------------------------------------+
 
 Si se administra usando y la cadena resultante es ilegal que el conjunto
 de caracteres dado, se emite una advertencia. Además, si está activado el
 strict SQL mode, el resultado de CHAR() se convierte en NULL.
 
 <b>Ejemplos</b>
 
 MariaDB [Prueba1]> SELECT CHAR( 77, 97, 114, '105', 97, '68', 66 );
 +------------------------------------------+
 | CHAR( 77, 97, 114, '105', 97, '68', 66 ) |
 +------------------------------------------+
 | MariaDB                                  |
 +------------------------------------------+
 1 row in set (0.00 sec)
 
 MariaDB [Prueba1]> SELECT CHAR( 77, 77.3, '77.3' );
 +--------------------------+
 | CHAR( 77, 77.3, '77.3' ) |
 +--------------------------+
 | MMM                      |
 +--------------------------+
 1 row in set, 1 warning (0.00 sec)
 
 MariaDB [Prueba1]> show warnings;
 +---------+------+-------------------------------------------+
 | Level   | Code | Message                                   |
 +---------+------+-------------------------------------------+
 | Warning | 1292 | Truncated incorrect INTEGER value: '77.3' |
 +---------+------+-------------------------------------------+
 1 row in set (0.00 sec)

== CHARACTER_LENGTH ==
 <b>Sintaxis</b>
 
 CHARACTER_LENGTH( str )
 
 <b>Descripción</b>
 
 CHARACTER_LENGTH() es sinónimo de CHAR_LENGTH().

== CHAR_LENGTH ==
 <b>Sintaxis</b>
 
 CHAR_LENGTH( str )
 
 <b>Dexcripción</b>
 
 Devuelve la longitud de la cadena str, medida en caracteres.
 Un carácter multi-byte cuenta como un solo carácter. Esto significa que para
 una cadena que contiene cinco caracteres de dos bytes, LENGTH() retorna 10,
 mientras que CHAR_LENGTH() devuelve 5. Si el argumento es NULL, devuelve NULL.
 
 Si str no es un valor de cadena, se convierte en una cadena.
 
 CHARACTER_LENGTH() es un sinónimo.
 
 <b>Ejemplos</b>
 
 MariaDB [Prueba1]> SELECT CHAR_LENGTH('MariaDB');
 +------------------------+
 | CHAR_LENGTH('MariaDB') |
 +------------------------+
 |                      7 |
 +------------------------+
 1 row in set (0.00 sec)
 
 MariaDB [Prueba1]> SELECT CHAR_LENGTH('Cómo');
 +----------------------+
 | CHAR_LENGTH('Cómo')  |
 +----------------------+
 |                    4 |
 +----------------------+
 1 row in set (0.01 sec)

== CONCAT ==
 <b>Sintaxis</b>
 
 CONCAT(str1,str2,...)
 
 <b>Dexcripción</b>
 
 Devuelve la cadena resultado de concatenar los argumentos. Puede tener
 uno o más argumentos. Si todos los argumentos son cadenas no binarias, 
 el resultado es una cadena no binaria. Si los argumentos incluyen todas 
 las cadenas binarias, el resultado es una cadena binaria. Un argumento 
 numérico se convierte en su forma de cadena binaria equivalente; si se 
 quiere evitar eso, se puede utilizar un tipo de conversión explícita.
 
 <b>Ejemplos</b>
 
 MariaDB [(none)]> SELECT CONCAT( 'Ma', 'ria', 'DB' );
 +---------------------------+
 | CONCAT('Ma', 'ria', 'DB') |
 +---------------------------+
 | MariaDB                   |
 +---------------------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT CONCAT( 'Ma', 'ria', NULL, 'DB' );
 +---------------------------------+
 | CONCAT('Ma', 'ria', NULL, 'DB') |
 +---------------------------------+
 | NULL                            |
 +---------------------------------+
 1 row in set (0.01 sec)
 
 MariaDB [(none)]> SELECT CONCAT( 42, 5 );
 +---------------+
 | CONCAT(42, 5) |
 +---------------+
 | 425           |
 +---------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT CONCAT( 42, .5 );
 +----------------+
 | CONCAT(42, .5) |
 +----------------+
 | 420.5          |
 +----------------+
 1 row in set (0.00 sec)
 
 MariaDB [(none)]> SELECT CONCAT( 'The value of @v is: ', IFNULL( @v, '' ) );
 +------------------------------------------------+
 | CONCAT('The value of @v is: ', IFNULL(@v, '')) |
 +------------------------------------------------+
 | The value of @v is:                            |
 +------------------------------------------------+
 1 row in set (0.00 sec)
 
== CONCAT_WS ==
 <b>Sintaxis</b>
 
 CONCAT_WS( separator, str1, str2, ... )
 
 <b>Descripción</b>
 
 CONCAT_WS() significa Concatenate con separador y es una forma especial
 de CONCAT(). El primer argumento es el separador para el resto de los argumentos.
 Se añade el separador entre las cuerdas para ser concatenados. El separador puede
 ser una cadena, al igual que el resto de los argumentos.
 
 Si el separador es NULL, el resultado es NULL; todos los demás valores NULL
 se omiten. Esto hace CONCAT_WS() adecuado cuando se desea concatenar algunos
 valores y evitar la pérdida de toda la información si uno de ellos es NULL.
 
 <b>Ejemplos</b>
 
 MariaDB [Prueba1]> SELECT CONCAT_WS(', ', 'Nombre', 'Apellodo Paterno', 'Apellido Materno' );
 +--------------------------------------------------------------------+
 | CONCAT_WS(', ', 'Nombre', 'Apellodo Paterno', 'Apellido Materno' ) |
 +--------------------------------------------------------------------+
 | Nombre, Apellodo Paterno, Apellido Materno                         |
 +--------------------------------------------------------------------+
 1 row in set (0.00 sec)
 
 MariaDB [Prueba1]> SELECT CONCAT_WS( '-', 'Piso', NULL, 'Quarto' );
 +------------------------------------------+
 | CONCAT_WS( '-', 'Piso', NULL, 'Quarto' ) |
 +------------------------------------------+
 | Piso-Quarto                              |
 +------------------------------------------+
 1 row in set (0.00 sec)
 
 MariaDB [Prueba1]> SET @a = 'a', @b = NULL, @c = 'c';
 Query OK, 0 rows affected (0.00 sec)
 
 MariaDB [Prueba1]> SELECT CONCAT_WS( '', @a, @b, @c );
 +-----------------------------+
 | CONCAT_WS( '', @a, @b, @c ) |
 +-----------------------------+
 | ac                          |
 +-----------------------------+
 1 row in set (0.00 sec)
 
 MariaDB [Prueba1]> SELECT CONCAT(@a, @b, @c );
 +---------------------+
 | CONCAT(@a, @b, @c ) |
 +---------------------+
 | NULL                |
 +---------------------+
 1 row in set (0.00 sec)
 
== CONVERT ==
 <b>Sintaxis</b>
 
 CONVERT( expr,type ), CONVERT( expr USING transcoding_name )

 <b><Descripción</b>
 
 The type puede ser uno de los siguiente valores:
 
    BINARY[(N)]
    CHAR[(N)]
    DATE
    DATETIME[(D)] — Decimal (D) specifier new in 5.3
    DECIMAL[(M[,D])]
    DOUBLE[(M[,D])] — New in 5.3
    INTEGER — New in 5.3
        Short for SIGNED INTEGER 
    SIGNED [INTEGER]
    TIME[(D)] — Decimal (D) specifier new in 5.3
    UNSIGNED [INTEGER] 
 
 Tenga en cuenta que en MariaDB, INT y INTEGER son la misma cosa.
 
 BINARIO produce una cadena con el tipo de datos binarios. Ver binario
 para una descripción de cómo esto afecta a las comparaciones. Si se da
 la longitud opcional N, BINARY (N) hace que el molde a utilizar no más
 de N bytes del argumento. Los valores más cortos que N bytes se rellenan
 con 0x00 bytes a una longitud de N.
 
 CHAR (N) hace que el reparto de utilizar no más de N caracteres del argumento.
 
 La principal diferencia entre el CAST() y CONVERT() es que CONVERT(expr, tipo)
 es la sintaxis ODBC mientras CAST(expr como tipo) y CONVERT(... USING ...) están
 SQL92 sintaxis.

 CONVERT() con USING se utiliza para convertir datos entre diferentes conjuntos
 de caracteres. En MariaDB, nombres de transcodificación son los mismos que
 establece el carácter correspondiente nombres. Por ejemplo, este comando convierte
 la cadena 'abc' en el juego de caracteres predeterminado a la cadena correspondiente
 en el conjunto de caracteres UTF-8:
 
 <b>Ejemplo</b>
 
 MariaDB [Prueba1]> SELECT LOWER( @x ), LOWER( CONVERT( @x USING latin1 ) );
 +-------------+-------------------------------------+
 | LOWER( @x ) | LOWER( CONVERT( @x USING latin1 ) ) |
 +-------------+-------------------------------------+
 | AardVark    | aardvark                            |
 +-------------+-------------------------------------+
 1 row in set (0.00 sec)
 
 


[[Category:MariaDB Desde la Consola]]
[[Category: CursoMatiaDB]]
