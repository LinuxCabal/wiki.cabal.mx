= RegEx =
<pre>
Expresiones regulares (llamadas REs, o regexes o los patrones regex) son esencialmente un pequeño,
lenguaje especializado de programación embebido dentro de Python y disponible a través del re módulo.
Usando este lenguaje para especificar las reglas de posibles cadenas de caracteres que desea buscar;
Este conjunto puede contener frases, o direcciones de correo electrónico, o comandos de TeX o algo
que te guste. Puedes entonces hacer preguntas como "Esta cadena coincide con el patrón?", o 
"Es un partido para el patrón en cualquier lugar de esta cadena?".

 También puede utilizar REs a modificar una cadena o dividirlo en varias formas.

El lenguaje de la expresión regular es relativamente pequeño y restringido, así que 
no todo el procesamiento de RegEX es  posible
</pre>.
=== RegEx Meta Caractares ===
<pre>
Los Meta Caractares son:

                         . ^ $ * + ? { } [ ] \ | ( )

Los metacaracteres '[' y ']' son usados para especificar un clase de caracteres que
quieres coincidir. Puedes especificar los caracteres individualmente o en rangos
de caracteres.Entonces; [abc] coincide con algún de los 
caracteres 'a', 'b', o 'c' y [a-c], es decir  el rango de caracteres 'a' a 'c'.
Si quieres buscar solo caracteres minusculas puedes escribir [a-z].

Metacaracteres no son activos a dentro de clases, entonces; [akm$] coincide a algún de
los caracteres 'a', 'k', 'm', or '$'. '$' normalmente es un metacaracter, pero adentro
de la clase de caracteres, el pierde su caracteristicas de metacaracter.

El caracter '^' usado como el primer caracter adentro de un class puede coincidir a
caracteres no espesificados. Entonces [^5] coincede a algún caracter que no es '5'.

Un metacaracter muy importante en Python RegEx es el diagonal; '\'. Asi cómo en literales
de cadenas de Python, el '\' seguida con varios caracters indica sequencias de significos
especiales. Se usa también para escapar otro metacaracters para utilizarlas en los patrones
entoces puedes escribir '\[' para indicar el metacaracter '[' literalmente y 
\\' para indicar el metacaracter '\' literalmente.

Algúnas de las sequencias de caracteres especiales representan caracteres muy utiles como
unidades de digitos o letras o espacio blanco, Por ejemplo '\w' coincide can algún caracter
alfannumérico que puede representar con [a-zA-Z0-9_].

Algunos de los sequencias especiales:

\d    Algún digito decimal [0-9].
\D    Ningún digito decimal [^0-9].
\s    Algún caracter de espacio blanco [ \t\n\r\f\v].
\S    Ningún caracter de espacio blanco [^ \t\n\r\f\v].
\w    Algún caracter alfanumerico [a-zA-Z0-9_].
\W    Ningún caracter alfanumerico [^a-zA-Z0-9_].

Puedes incluir las sequencias de caracteres especiales en una clase por ejemplo:
[\s,.] coresponde a algún caracter de espacio blanco, o ',' o '.'.

La sequencia especial '.' coresponde a algún caracter con excepción de
línea nueva. Existe también (re.DOTALL) que coresponde a algún caracter, línea nueva incluida.
</pre>

=== Repetición ===

<pre>
Puede especificar que partes de la RE se deben repetir un determinado número de veces.

El primer metacaracter para repetir cosas que vamos a ver es *. * No coincide con el caracter literal '*', se especifica que el caracter anterior se puede emparejar cero o más veces, en lugar de una sola vez.

Por ejemplo, ca * t coincidirá a ct; (0 a caracteres), cat; (1 a caracter), caaat; (3 a caracteres ), y así sucesivamente. El motor RE tiene varias limitaciones internas derivadas del tamaño del de C tipo int que evitar que se emparejan más de 2 mil millones a los patrones repitidos. Generalmente no se escriben para que coincida con la cantidad de datos.

<p>Repetitions such as * are greedy; when repeating a RE, the matching
engine will try to repeat it as many times as possible. If later portions of the
pattern don't match, the matching engine will then back up and try again with
few repetitions.</p>
<p>A step-by-step example will make this more obvious.  Let's consider the
expression a[bcd]*b.  This matches the letter 'a', zero or more letters
from the class [bcd], and finally ends with a 'b'.  Now imagine matching
this RE against the string abcbd.</p>

</pre>
<table border="1">
  <tr>
    <th>
      Step
    </th>
    <th>
      Matched
    </th>
    <th>
      Explanation
    </th>
  </tr>
  <tr>
    <td>
      1
    </td>
    <td>
      a
    </td>
    <td>
      The 'a' in the RE matches.
    </td>
  </tr>
  <tr>
    <td>
      2
    </td>
    <td>
      abcbd
    </td>
    <td>
      The engine matches [bcd]*,
      going as far as it can, which
      is to the end of the string.
    </td>
  </tr>
  <tr>
    <td>
      3
    </td>
    <td>
      Failure
    </td>
    <td>
      The engine tries to match
      'b', but the current position
       is at the end of the string, so
       it fails.
    </td>
  </tr>
  <tr>
    <td>
      4
    </td>
    <td>
      abcb
    </td>
    <td>
      Back up, so that [bcd]*
      matches one less character.
    </td>
  </tr>
  <tr
    <td>
      5
    </td>
    <td>
      Failure
    </td>
    <td>
      Try 'b' again, but the
      current position is at the last
      character, which is a 'd'.
    </td>
  </tr>
  <tr>
    <td>
      6
    </td>
    <td>
      abc
    </td>
    <td>
      Back up again, so that
      [bcd]* is only matching
      bc.
    </td>
  </tr>
  <tr>
    <td>
      6
    </td>
    <td>
      abcb
    </td>
    <td>
      Try 'b' again. This time
      the character at the
      current position is 'b', so
      it succeeds.
    </td>
  </tr>
</table>
<pre>
<p>The end of the RE has now been reached, and it has matched abcb.  This
demonstrates how the matching engine goes as far as it can at first, and if no
match is found it will then progressively back up and retry the rest of the RE
again and again.  It will back up until it has tried zero matches for
[bcd]*, and if that subsequently fails, the engine will conclude that the
string doesn't match the RE at all.</p>


</pre>
[[Category:Programación en Python]]
[[Category:PythonCabal]]
[[Category:CursoPython]]
