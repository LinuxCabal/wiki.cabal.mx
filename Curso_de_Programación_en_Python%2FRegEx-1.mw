= RegEx =
<pre>
Expresiones regulares (llamadas REs, o regexes o los patrones regex) son esencialmente un pequeño,
lenguaje especializado de programación embebido dentro de Python y disponible a través del re módulo.
Usando este lenguaje para especificar las reglas de posibles cadenas de caracteres que desea buscar;
Este conjunto puede contener frases, o direcciones de correo electrónico, o comandos de TeX o algo
que te guste. Puedes entonces hacer preguntas como "Esta cadena coincide con el patrón?", o 
"Es un partido para el patrón en cualquier lugar de esta cadena?".

 También puede utilizar REs a modificar una cadena o dividirlo en varias formas.

El lenguaje de la expresión regular es relativamente pequeño y restringido, así que 
no todo el procesamiento de RegEX es  posible
</pre>.
=== RegEx Meta Caractares ===
<pre>
Los Meta Caractares son:

                         . ^ $ * + ? { } [ ] \ | ( )

Los metacaracteres '[' y ']' son usados para especificar un clase de caracteres que
quieres coincidir. Puedes especificar los caracteres individualmente o en rangos
de caracteres.Entonces; [abc] coincide con algún de los 
caracteres 'a', 'b', o 'c' y [a-c], es decir  el rango de caracteres 'a' a 'c'.
Si quieres buscar solo caracteres minusculas puedes escribir [a-z].

Metacaracteres no son activos a dentro de clases, entonces; [akm$] coincide a algún de
los caracteres 'a', 'k', 'm', or '$'. '$' normalmente es un metacaracter, pero adentro
de la clase de caracteres, el pierde su caracteristicas de metacaracter.

El caracter '^' usado como el primer caracter adentro de un class puede coincidir a
caracteres no espesificados. Entonces [^5] coincede a algún caracter que no es '5'.

Un metacaracter muy importante en Python RegEx es el diagonal; '\'. Asi cómo en literales
de cadenas de Python, el '\' seguida con varios caracters indica sequencias de significos
especiales. Se usa también para escapar otro metacaracters para utilizarlas en los patrones
entoces puedes escribir '\[' para indicar el metacaracter '[' literalmente y 
\\' para indicar el metacaracter '\' literalmente.

Algúnas de las sequencias de caracteres especiales representan caracteres muy utiles como
unidades de digitos o letras o espacio blanco, Por ejemplo '\w' coincide can algún caracter
alfannumérico que puede representar con [a-zA-Z0-9_].

Algunos de los sequencias especiales:

\d    Algún digito decimal [0-9].
\D    Ningún digito decimal [^0-9].
\s    Algún caracter de espacio blanco [ \t\n\r\f\v].
\S    Ningún caracter de espacio blanco [^ \t\n\r\f\v].
\w    Algún caracter alfanumerico [a-zA-Z0-9_].
\W    Ningún caracter alfanumerico [^a-zA-Z0-9_].

Puedes incluir las sequencias de caracteres especiales en una clase por ejemplo:
[\s,.] coresponde a algún caracter de espacio blanco, o ',' o '.'.

La sequencia especial '.' coresponde a algún caracter con excepción de
línea nueva. Existe también (re.DOTALL) que coresponde a algún caracter, línea nueva incluida.
</pre>

=== Repetición ===

<pre>
Puede especificar que partes de la RE se deben repetir un determinado número de veces.

El primer metacaracter para repetir cosas que vamos a ver es *. * No coincide con el 
caracter literal '*', se especifica que el caracter anterior se puede emparejar cero 
o más veces, en lugar de una sola vez.

Por ejemplo, ca * t coincidirá a ct; (0 a caracteres), cat; (1 a caracter), 
caaat; (3 a caracteres ), y así sucesivamente. El motor RE tiene varias limitaciones 
internas derivadas del tamaño del de C tipo int que evitar que se emparejan más de 
2 mil millones a los patrones repitidos. Generalmente no se escriben para que coincida 
con la cantidad de datos.

Another repeating metacharacter is +, which matches one or more times. Pay careful attention to the difference between * and +; * matches zero or more times, so whatever’s being repeated may not be present at all, while + requires at least one occurrence. To use a similar example, ca+t will match cat (1 a), caaat (3 a‘s), but won’t match ct.

There are two more repeating qualifiers. The question mark character, ?, matches either once or zero times; you can think of it as marking something as being optional. For example, home-?brew matches either homebrew or home-brew.

The most complicated repeated qualifier is {m,n}, where m and n are decimal integers. This qualifier means there must be at least m repetitions, and at most n. For example, a/{1,3}b will match a/b, a//b, and a///b. It won’t match ab, which has no slashes, or a////b, which has four.

You can omit either m or n; in that case, a reasonable value is assumed for the missing value. Omitting m is interpreted as a lower limit of 0, while omitting n results in an upper bound of infinity — actually, the upper bound is the 2-billion limit mentioned earlier, but that might as well be infinity.

Readers of a reductionist bent may notice that the three other qualifiers can all be expressed using this notation. {0,} is the same as *, {1,} is equivalent to +, and {0,1} is the same as ?. It’s better to use *, +, or ? when you can, simply because they’re shorter and easier to read.

</pre>
[[Category:Programación en Python]]
[[Category:PythonCabal]]
[[Category:CursoPython]]
